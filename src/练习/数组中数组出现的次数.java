package 练习;

/**
 * @author mufan
 * @date 2020/4/29
 * 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
 * 输入：nums = [4,1,4,6]
 * 输出：[1,6] 或 [6,1]
 */
public class 数组中数组出现的次数 {
    /**
     * 使用异或
     * 数字自己和自己进行异或结果为0
     * ^特点：相同则为0，不同则为1；
     * &特点：同时为1才为1，否则为0
     * 思路：
     * 将数组整体进行异或操作，得到的值为两个不同值的异或结果
     * 找到结果中二进制低位的1
     * 为什么要找最低位的1？
     * 是因为我们要将数组分为两个小的数组，两个不同的数异或二级制必定包含有至少一个1
     * 为什么要找1？
     * 因为我们拿到最后的异或结果，这时候我们根据异或的特点，相同为0，不同为1，这里的不同为1，
     * 因为两个数异或二进制位为1，说明两个数二进制的最低位肯定是不同的
     * 找到最低位的1如何处理？
     * 根据&的特点同时为1则为1否则为0，这时候根据这个最低位的1就可以将数组分为两个小的数组
     * 然后每个小的数组进行异或，这时候每个数组中出现我们想要的结果
     */
    public int[] singleNumbers(int[] nums) {
        int sum = 0;
        //将数组所有元素进行异或，最后的结果一定是那两个单一数字的异或结果
        //用示例[4,4,6,1]最后的抑或结果就是 6和1异或的结果 7
        for (int value : nums) {
            sum ^= value;
        }
        int first = 1;
        //通过与运算找到result第一个不为0的首位，7=>0111，也就是第一位
        while ((sum & first) == 0) {
            first = first << 1;
        }
        //first为1，所以我们可以根据数组元素的二进制低位第一位是否为1，将数组分为2类，
        // 示例数组可以分为     低位第一位为0：[4,4,6]     低位第一位为1：[1]
        //此时再将两个数组两两异或就可以得到最终结果。
        int[] result = new int[2];
        for (int num : nums) {
            //将数组分类。
            if ((num & first) == 0) {
                result[0] ^= num;
            } else {
                result[1] ^= num;
            }
        }
        return result;
    }
}
